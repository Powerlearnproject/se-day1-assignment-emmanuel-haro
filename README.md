[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18435987&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engieering is a branch of computer science used for developing, testing and maintaining software.

Importance of software enegineering in in the technology include :
Reliability, it enables software performs as expeccted without bias especially for critical application like healthcare and finance.
Scalability and Flexibility, it ensures that the system can handle an increased load without affecting performance.
Effeciency, it aids to optimize developer workflow while maintaining high quality standards.
Security, - implement protection practice like authentication, authorization and encryption to secure users information. Identify and describe at least three key milestones in the evolution of software engineering.

Identify and describe at least three key milestones in the evolution of software engineering
Mastering Complexity, Early efforts focused on controlling the inherent complexity of software systems through modularity, abstraction, and structured programming.
Mastering Process , The focus then shifted to formalizing and improving the software development process, using methodologies that ensured higher quality, efficiency, and predictability.
Mastering Machine, Finally, advancements in hardware, automation, and modern development tools revolutionized the way software is created, deployed, and maintained, enabling faster, scalable, and more reliable software systems.

List and briefly explain the phases of the Software Development Life Cycle.
planning - specify the software requirement or intent and scope.
requirement analysis - identify the final user requirement.
design - building the framework.
coding - the conversion of software design into code.
testing - verify the software for any bugs and glitches

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
waterfall method - Sequential and linear, one phase is done before moving to the next.
- Has Low flexibility,
changes are hard to incorporate once a phase has been completed.
- Customer feedback comes late, following the product development.
- Tests are conducted after the development process.
  
agile method - Incremental and iterative, with iterations (sprints).
- Has High flexibility, can accommodate changing requirements.
- Regular customer input is included in every sprint.
- Testing is continuous and is conducted after each iteration.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer - creating programs,applications and systems using programming languages and frameworks.
- putting software into place and fixing it to maintain its functionality.
- collaborating with other programmers to ensure best practice in creating
software.
- reporting to the project manager the status of software development.
Quality Assurance Engineer - collaborate with stakeholders to collect and clarify software requirement.
- define development standards and procedures for the programmers to follow
- make the software compliant to the requirement before deployment.
- review the product and identify bugs and suggest changes to make them more efficient.
- develop and execute automation scripts from open source tools.
Project Manager - develop and manage the development team for software.
- conduct discussion with client and software developers about the project and it's requirement.
- develop blueprint of the project.
- monitor and communicate information of the project milestone.
- deliver the entire software to the customer and monitor it regularly.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment (IDE) is a computer program that allows other computer programs to be created by providing a platform on which code can be authored, compiled, and debugged, perhaps with value-added features that ease the development. eg Visual Studio Code (VSCode)
importance:
There are syntax rules governing how programming statements must be structured.
As an IDE knows these rules, it has plenty of clever features to write or alter the source code automatically.
An IDE can format the written text by automatically italicizing or bolding certain words, or applying different font colors. These visual cues make the source code more readable and give instant feedback on unwanted syntax errors.
an IDE can prompt the completion of a code statement when the developer begins typing.
IDEs improve programmer productivity by automating repetitive development
functions that are typically part of every code alteration. The following are some examples of regular coding tasks that an IDE carries out.
An IDE compiles or interprets the code into a simplified language that is understandable by the operating system. - There exist programming languages that embrace just-in-time compilation, enabling the IDE to compile readable code into machine code within the application.
IDE offers unit tests to be automated locally before integrating the software with
code from other developers and running more sophisticated integration tests.
Debugging IDE offers stepping through code line-by-line as it executes and analyzing
code behavior. IDEs also include several debugging tools that detect bugs formed by
human error in real time, even as the developer types.
Version Control Systems (VCS) - computer programs to help software teams manage changes to source code over time. eg Git

importance:
Collaboration, Enables multiple developers to work on the same codebase without conflicts.
Change Tracking,  Keeps a fine-grained history of changes so that it's simple to analyze each change.
-Branching and Merging, Enables creating branches for new features and merging them back into the master code.
Error Recovery, Enables reverting to previous versions if new changes introduce errors

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
-technological advancement at a breakneck pace places tremendous pressure on software engineers to stay current.
Solution: adopting continuous learning practices and using agile methodologies to adapt with emerging trends, maintaining their cutting edge in an ever-changing industry.
Time Constraints - Software engineering is a time-consuming and stressful profession, with engineers working under stress to deliver within tight deadlines.
Solution: adopt agile methodologies, such as Scrum, to streamline processes by dividing large projects into bite-sized sprints
-Limited Infrastructure - limited high-performance software engineering tools and computing platforms and inefficient data storage architectures.
Solution: software engineers must rely heavily on a robust infrastructure to perform their work effectively.
Changing Software Requirements - Software requirements are dynamic and change very frequently, making it challenging for engineers to design and implement solutions that meet users' needs while taking into account future updates and bug fixes.
Solution: engineers can use techniques like agile development, which emphasizes iterative refinement and flexibility, and modular design, which facilitates flexibility by breaking up systems into manageable, separate components.
Software Security - Secure software writing is a challenging and complex endeavor.
Solution: learn how to defend against hacking, malware, phishing, insider and third-party attacks
Software Accessibility and Usability - Software that is overly complicated will irk or confuse end-users.
Solution: Use scalable design, Emphasize dependability

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit tests - are nearest to the source of the application, They test individual methods and functions of classes, components, or modules your software is utilizing.
- it ensures that each unit is functioning as it is supposed to, regardless of other parts.
Integration tests - ensure that different modules or services your application is utilizing work well with each other.
- help to ensure data pass well between modules and interfaces respond as expected.
System testing - directed towards the total software system overall, including all functionalities and interactions.
-It help to confirm that the system meets all functional and non-functional requirements, e.g., performance, usability, and security.
Acceptance tests - are formal tests that verify whether a system meets business requirements. They require the whole application to be running while the test is ongoing and are designed to simulate user activity.
- Whether the software meets the needs of the end-user and is ready for deployment.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
prompt engineering is the process whereby you guide generative AI solutions to generate desired output.
Importance:
Improved user experience - Prompt engineering allows users to obtain relevant results within the first prompt. It helps in minimizing the bias that may be due to inherent human bias in the training data of the large language models.
Improved flexibility - A prompt engineer can create prompts with
domain-agnostic instructions that highlight logical relationships and general patterns.
developer control - Prompt engineering enables developers to gain more control over how the users engage with the AI. Effective prompts provide intent and establish context to the large language models. Provide an example of a vague prompt and then clarify it by making it concise, specific, and clear.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Draw a picture of a person
Draw a full-body portrait of a young woman with long brown hair, red jacket, and blue jeans standing in a park on a sunny day with trees and grass in the background.
Clarity: The new prompt is clear about what is being asked (a full-body portrait) rather than a mere "person."
Specific Details: The details of the woman's appearance (long brown hair, red jacket, blue
jeans) and the setting (park, sunny day, trees, grass) gives clear directions on the picture to be created.
Direct: The additional information gives a clear picture without being overly complex, making it simple for the artist to understand what is needed.
